from __future__ import annotations

from dataclasses import dataclass, fields
from datetime import datetime, timezone
from typing import Any, ClassVar
from uuid import UUID, uuid4


@dataclass(frozen=True, slots=True)
class Event:
    """
    Base class for all domain events.

    Events are:
    - immutable
    - timestamped in UTC
    - uniquely identifiable
    - totally orderable via `sequence`
    - safe to replay and audit
    """

    # Unique event identifier
    event_id: UUID

    # UTC timestamp of event creation
    timestamp_utc: datetime

    # Monotonic sequence number for deterministic ordering.
    # EngineState should allocate this via next_sequence().
    # For boundary markers (e.g., RunStarted) you can leave it as 0 if desired,
    # but in production we typically still sequence everything.
    sequence: int = 0

    # Event type name (static per subclass)
    event_type: ClassVar[str]

    @classmethod
    def create(cls, **kwargs) -> "Event":
        """
        Factory method to create a new event with autogenerated ID and timestamp.
        """
        return cls(
            event_id=uuid4(),
            timestamp_utc=datetime.now(timezone.utc),
            **kwargs,
        )

    def to_dict(self) -> dict[str, Any]:
        """
        Convert the event into a JSON-serializable dict.

        - event_id is serialized as str(UUID)
        - timestamp_utc is serialized as ISO-8601 string
        - event_type is included explicitly
        - all dataclass fields are included (including sequence + subclass fields)
        """
        out: dict[str, Any] = {"event_type": self.event_type}

        for f in fields(self):
            v = getattr(self, f.name)
            if isinstance(v, UUID):
                out[f.name] = str(v)
            elif isinstance(v, datetime):
                out[f.name] = v.astimezone(timezone.utc).isoformat()
            else:
                out[f.name] = v

        return out
